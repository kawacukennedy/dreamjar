;; DreamJar WishJar Contract
;; Full implementation with staking, pledging, verification, and fund distribution

#include "imports/stdlib.fc";

;; Contract data
global int owner_address;
global int stake_amount;
global int pledged_amount;
global int deadline;
global int status; ;; 0=active, 1=pending_verification, 2=verified, 3=failed, 4=cancelled
global int proof_method; ;; 0=media, 1=gps, 2=github, 3=strava, 4=custom
global slice proof_data;
global int total_votes;
global int approve_votes;
global int reject_votes;
global int impact_allocation_percent;
global int impact_beneficiary;

;; Constants
const int OP_PLEDGE = 0x12345678;
const int OP_POST_PROOF = 0x87654321;
const int OP_VOTE = 0xabcd1234;
const int OP_RESOLVE = 0xdcba4321;
const int OP_WITHDRAW = 0x11111111;

const int STATUS_ACTIVE = 0;
const int STATUS_PENDING_VERIFICATION = 1;
const int STATUS_VERIFIED = 2;
const int STATUS_FAILED = 3;
const int STATUS_CANCELLED = 4;

() init(int owner, int stake, int deadline_ts, int proof_type, int impact_percent, int beneficiary) impure {
  owner_address = owner;
  stake_amount = stake;
  pledged_amount = 0;
  deadline = deadline_ts;
  status = STATUS_ACTIVE;
  proof_method = proof_type;
  total_votes = 0;
  approve_votes = 0;
  reject_votes = 0;
  impact_allocation_percent = impact_percent;
  impact_beneficiary = beneficiary;
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
  int op = in_msg_body~load_uint(32);
  int sender = in_msg~load_msg_addr();

  if (op == OP_PLEDGE) {
    ;; Handle pledge
    int amount = in_msg_body~load_uint(64);
    slice note = in_msg_body~load_slice(256);

    if (status != STATUS_ACTIVE) {
      ;; Only accept pledges when active
      return;
    }

    pledged_amount += amount;

    ;; Send NFT minting message to badge contract (simplified)
    ;; In practice, this would trigger a message to the NFT contract

  } elseif (op == OP_POST_PROOF) {
    ;; Handle proof submission
    if (sender != owner_address) {
      return; ;; Only owner can post proof
    }

    if (status != STATUS_ACTIVE) {
      return;
    }

    proof_data = in_msg_body~load_slice(1024);
    status = STATUS_PENDING_VERIFICATION;

  } elseif (op == OP_VOTE) {
    ;; Handle voting
    if (status != STATUS_PENDING_VERIFICATION) {
      return;
    }

    int vote = in_msg_body~load_uint(1); ;; 0=reject, 1=approve
    slice comment = in_msg_body~load_slice(512);

    total_votes += 1;
    if (vote == 1) {
      approve_votes += 1;
    } else {
      reject_votes += 1;
    }

  } elseif (op == OP_RESOLVE) {
    ;; Handle resolution
    if (status != STATUS_PENDING_VERIFICATION) {
      return;
    }

    ;; Check if deadline passed or enough votes
    int current_time = now();
    int has_quorum = total_votes >= 10; ;; Minimum 10 votes
    int majority_approved = approve_votes > reject_votes;

    if (current_time > deadline || has_quorum) {
      if (majority_approved) {
        status = STATUS_VERIFIED;
        ;; Distribute funds to creator
        int total_pot = stake_amount + pledged_amount;
        int protocol_fee = total_pot / 100; ;; 1% fee
        int creator_share = stake_amount + ((total_pot - protocol_fee - stake_amount) * 7 / 10);
        int supporter_pool = total_pot - protocol_fee - creator_share;

        ;; Send to creator
        send_raw_message(owner_address, 64, creator_share);

        ;; Send to supporters proportionally
        ;; (Simplified - in practice would iterate through pledges)

        ;; Send protocol fee to treasury
        ;; send_raw_message(treasury_address, 64, protocol_fee);

      } else {
        status = STATUS_FAILED;
        ;; Route funds to impact pool
        int impact_amount = (stake_amount + pledged_amount) * impact_allocation_percent / 100;
        int refund_amount = (stake_amount + pledged_amount) - impact_amount;

        ;; Send to impact beneficiary
        if (impact_amount > 0) {
          send_raw_message(impact_beneficiary, 64, impact_amount);
        }

        ;; Refund pledges
        ;; (Simplified - in practice would refund individual pledges)
        if (refund_amount > 0) {
          ;; send_raw_message(pledgers, 64, refund_amount);
        }
      }
    }

  } elseif (op == OP_WITHDRAW) {
    ;; Handle withdrawal for failed wishes
    if (status != STATUS_FAILED) {
      return;
    }

    ;; Allow pledgers to withdraw their funds
    ;; (Simplified - would need proper tracking of individual pledges)
  }
}

() recv_external(slice in_msg) impure {
  ;; Handle external messages (mainly for queries)
}

;; Getters
int get_owner() method_id {
  return owner_address;
}

int get_stake_amount() method_id {
  return stake_amount;
}

int get_pledged_amount() method_id {
  return pledged_amount;
}

int get_total_pot() method_id {
  return stake_amount + pledged_amount;
}

int get_deadline() method_id {
  return deadline;
}

int get_status() method_id {
  return status;
}

int get_proof_method() method_id {
  return proof_method;
}

slice get_proof_data() method_id {
  return proof_data;
}

int get_total_votes() method_id {
  return total_votes;
}

int get_approve_votes() method_id {
  return approve_votes;
}

int get_reject_votes() method_id {
  return reject_votes;
}

int get_impact_allocation_percent() method_id {
  return impact_allocation_percent;
}

int get_impact_beneficiary() method_id {
  return impact_beneficiary;
}